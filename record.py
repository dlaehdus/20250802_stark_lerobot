# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Records a dataset. Actions for the robot can be either generated by teleoperation or by a policy.

Example:

```shell
lerobot-record \
    --robot.type=so100_follower \
    --robot.port=/dev/tty.usbmodem58760431541 \
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
    --robot.id=black \
    --dataset.repo_id=aliberts/record-test \
    --dataset.num_episodes=2 \
    --dataset.single_task="Grab the cube" \
    # <- Teleop optional if you want to teleoperate to record or in between episodes with a policy \
    # --teleop.type=so100_leader \
    # --teleop.port=/dev/tty.usbmodem58760431551 \
    # --teleop.id=blue \
    # <- Policy optional if you want to record with a policy \
    # --policy.path=${HF_USER}/my_policy \
```

Example recording with bimanual so100:
```shell
lerobot-record \
  --robot.type=bi_so100_follower \
  --robot.left_arm_port=/dev/tty.usbmodem5A460851411 \
  --robot.right_arm_port=/dev/tty.usbmodem5A460812391 \
  --robot.id=bimanual_follower \
  --robot.cameras='{
    left: {"type": "opencv", "index_or_path": 0, "width": 640, "height": 480, "fps": 30},
    top: {"type": "opencv", "index_or_path": 1, "width": 640, "height": 480, "fps": 30},
    right: {"type": "opencv", "index_or_path": 2, "width": 640, "height": 480, "fps": 30}
  }' \
  --teleop.type=bi_so100_leader \
  --teleop.left_arm_port=/dev/tty.usbmodem5A460828611 \
  --teleop.right_arm_port=/dev/tty.usbmodem5A460826981 \
  --teleop.id=bimanual_leader \
  --display_data=true \
  --dataset.repo_id=${HF_USER}/bimanual-so100-handover-cube \
  --dataset.num_episodes=25 \
  --dataset.single_task="Grab and handover the red cube to the other arm"
```
"""

import logging
# ë¡œê¹… ì‹œìŠ¤í…œ import
import time
# ì‹œê°„ ì¸¡ì • ë° ì œì–´ìš© import
from dataclasses import asdict, dataclass
# ë°ì´í„°í´ë˜ìŠ¤ ê´€ë ¨ í•¨ìˆ˜ë“¤ import
from pathlib import Path
# íŒŒì¼ ê²½ë¡œ ì²˜ë¦¬ìš© import
from pprint import pformat
# ì˜ˆìœ ì¶œë ¥ í¬ë§·íŒ… í•¨ìˆ˜ import
from lerobot.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
# ì¹´ë©”ë¼ ì„¤ì • ê¸°ë³¸ í´ë˜ìŠ¤ import (ì‚¬ìš©ë˜ì§€ ì•Šì•„ë„ import)
from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
# OpenCVì™€ RealSense ì¹´ë©”ë¼ ì„¤ì • í´ë˜ìŠ¤ë“¤ import
from lerobot.configs import parser
#  LeRobot ì„¤ì • íŒŒì„œ import (ëª…ë ¹ì¤„ ì¸ìˆ˜ ì²˜ë¦¬ìš©)
from lerobot.configs.policies import PreTrainedConfig
# ì‚¬ì „ í›ˆë ¨ëœ ì •ì±… ì„¤ì • í´ë˜ìŠ¤ import
from lerobot.datasets.image_writer import safe_stop_image_writer
# ì´ë¯¸ì§€ ì €ì¥ ì‘ì—…ì˜ ì•ˆì „í•œ ì¤‘ë‹¨ì„ ìœ„í•œ ë°ì½”ë ˆì´í„° import
from lerobot.datasets.lerobot_dataset import LeRobotDataset
# LeRobot ë°ì´í„°ì…‹ í´ë˜ìŠ¤ import (HDF5 ê¸°ë°˜ ë°ì´í„° ì €ì¥)
from lerobot.datasets.utils import build_dataset_frame, hw_to_dataset_features
# ë°ì´í„°ì…‹ í”„ë ˆì„ êµ¬ì„±ê³¼ í•˜ë“œì›¨ì–´-ë°ì´í„°ì…‹ íŠ¹ì„± ë³€í™˜ ìœ í‹¸ë¦¬í‹°
from lerobot.datasets.video_utils import VideoEncodingManager
# ë¹„ë””ì˜¤ ì¸ì½”ë”© ê´€ë¦¬ì (ì¹´ë©”ë¼ ì´ë¯¸ì§€ë¥¼ ë¹„ë””ì˜¤ë¡œ ì••ì¶•)
from lerobot.policies.factory import make_policy
# ì •ì±… íŒ©í† ë¦¬ í•¨ìˆ˜ (ì„¤ì •ìœ¼ë¡œë¶€í„° ì •ì±… ê°ì²´ ìƒì„±)
from lerobot.policies.pretrained import PreTrainedPolicy
#  ì‚¬ì „ í›ˆë ¨ëœ ì •ì±… í´ë˜ìŠ¤
from lerobot.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    bi_so100_follower,
    hope_jr,
    koch_follower,
    my_follower,
    make_robot_from_config,
    so100_follower,
    so101_follower,
)
# ë¡œë´‡ ê´€ë ¨ í´ë˜ìŠ¤ë“¤ê³¼ íŒ©í† ë¦¬ í•¨ìˆ˜ë“¤ import
from lerobot.teleoperators import (  # noqa: F401
    Teleoperator,
    TeleoperatorConfig,
    bi_so100_leader,
    homunculus,
    koch_leader,
    my_leader,
    make_teleoperator_from_config,
    so100_leader,
    so101_leader,
)
# í…”ë ˆì˜¤í¼ë ˆì´í„° ê´€ë ¨ í´ë˜ìŠ¤ë“¤ê³¼ íŒ©í† ë¦¬ í•¨ìˆ˜ë“¤ import
from lerobot.teleoperators.keyboard.teleop_keyboard import KeyboardTeleop
# í‚¤ë³´ë“œ í…”ë ˆì˜¤í¼ë ˆì´ì…˜ í´ë˜ìŠ¤ import (ì´ë™ ë¡œë´‡ìš©)
from lerobot.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
# ì œì–´ ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë“¤ import
from lerobot.utils.robot_utils import busy_wait
# ì •ë°€í•œ íƒ€ì´ë° ì œì–´ë¥¼ ìœ„í•œ busy_wait í•¨ìˆ˜
from lerobot.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
# ì¼ë°˜ ìœ í‹¸ë¦¬í‹°ë“¤: ì•ˆì „í•œ PyTorch ë””ë°”ì´ìŠ¤, ë¡œê¹… ì´ˆê¸°í™”, ìŒì„± ì¶œë ¥
from lerobot.utils.visualization_utils import _init_rerun, log_rerun_data
# Rerun ì‹œê°í™” ê´€ë ¨ ìœ í‹¸ë¦¬í‹°ë“¤



# ë°ì´í„°ì…‹ ê¸°ë¡ ì„¤ì •ì„ ë‹´ì„ ë°ì´í„°í´ë˜ìŠ¤ ì •ì˜
# repo_id (str): Hugging Face Hub ìƒì˜ ë°ì´í„°ì…‹ ì´ë¦„. "{ì‚¬ìš©ìëª…}/{ë°ì´í„°ì…‹ëª…}" í˜•ì‹.
# --dataset.repo_id ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
# single_task (str): ë…¹í™” ì¤‘ ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì˜ ê°„ë‹¨í•œ ì„¤ëª…(ì˜ˆ: "Pick the blue").
# root (str | Path | None): ë°ì´í„°ì…‹ì„ ì €ì¥í•  ë¡œì»¬ ë””ë ‰í„°ë¦¬ ë£¨íŠ¸. Noneë©´ ê¸°ë³¸ ìœ„ì¹˜.
# fps (int=30): ë…¹í™” ë£¨í”„ì˜ ëª©í‘œ í”„ë ˆì„ë ˆì´íŠ¸. ì œì–´ ë£¨í”„ ì£¼ê¸° ë° ì´ë¯¸ì§€/ë¹„ë””ì˜¤ ì €ì¥ ê°„ê²© ê¸°ì¤€.
# episode_time_s (int|float=60): 1ê°œ ì—í”¼ì†Œë“œë¥¼ ë…¹í™”í•˜ëŠ” ì‹œê°„(ì´ˆ).
# reset_time_s (int|float=60): ê° ì—í”¼ì†Œë“œ í›„ í™˜ê²½ ë¦¬ì…‹ì— ì‚¬ìš©í•˜ëŠ” ì‹œê°„(ì´ˆ).
# num_episodes (int=50): ë…¹í™”í•  ì—í”¼ì†Œë“œ ê°œìˆ˜(ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜).
# video (bool=True): ì´ë¯¸ì§€ í”„ë ˆì„ì„ ë¹„ë””ì˜¤ë¡œ ì¸ì½”ë”©í• ì§€ ì—¬ë¶€. Trueë©´ ë¹„ë””ì˜¤ ìƒì„±.
# push_to_hub (bool=True): ë…¹í™” ì™„ë£Œ í›„ Hubì— ì—…ë¡œë“œí• ì§€ ì—¬ë¶€.
# private (bool=False): Hubì— ë¹„ê³µê°œ ë°ì´í„°ì…‹ìœ¼ë¡œ ì—…ë¡œë“œí• ì§€ ì—¬ë¶€.
# tags (list[str] | None): Hubì— í•¨ê»˜ ì—…ë¡œë“œí•  íƒœê·¸ ëª©ë¡.
# num_image_writer_processes (int=0): ì´ë¯¸ì§€ ì €ì¥ì— ì‚¬ìš©í•  ì„œë¸Œí”„ë¡œì„¸ìŠ¤ ìˆ˜. 0ì´ë©´ í”„ë¡œì„¸ìŠ¤ ì—†ì´ ìŠ¤ë ˆë“œë§Œ ì‚¬ìš©.
# num_image_writer_threads_per_camera (int=4): ì¹´ë©”ë¼ë³„ ì´ë¯¸ì§€ ì €ì¥ ìŠ¤ë ˆë“œ ìˆ˜. ë„ˆë¬´ í¬ë©´ ë©”ì¸ ì“°ë ˆë“œê°€ ë§‰í˜€ í…”ë ˆì˜µ FPS ì €í•˜ ê°€ëŠ¥.
# video_encoding_batch_size (int=1): ë¹„ë””ì˜¤ ì¸ì½”ë”©ì„ ëª‡ ê°œ ì—í”¼ì†Œë“œ ë‹¨ìœ„ë¡œ ë°°ì¹˜ ì²˜ë¦¬í• ì§€. 1ì´ë©´ ë§¤ ì—í”¼ì†Œë“œ ì§í›„ ì¸ì½”ë”©.
@dataclass
class DatasetRecordConfig:
    # Dataset identifier. By convention it should match '{hf_username}/{dataset_name}' (e.g. `lerobot/test`).
    repo_id: str
    # ë°ì´í„°ì…‹ ì‹ë³„ì, HuggingFace Hub ì €ì¥ì†Œ í˜•ì‹ (ì˜ˆ: "limdoyeon/robot-demos")
    # A short but accurate description of the task performed during the recording (e.g. "Pick the Lego block and drop it in the box on the right.")
    single_task: str
    # ê¸°ë¡ ì¤‘ ìˆ˜í–‰í•  ì‘ì—…ì˜ ê°„ë‹¨í•˜ê³  ì •í™•í•œ ì„¤ëª…
    # Root directory where the dataset will be stored (e.g. 'dataset/path').
    root: str | Path | None = None
    # ë°ì´í„°ì…‹ì´ ì €ì¥ë  ë£¨íŠ¸ ë””ë ‰í† ë¦¬ (ê¸°ë³¸ê°’: None)
    # Limit the frames per second.
    fps: int = 30
    # ì´ˆë‹¹ í”„ë ˆì„ ìˆ˜ ì œí•œ (ê¸°ë³¸ê°’: 30 FPS)
    # Number of seconds for data recording for each episode.
    episode_time_s: int | float = 60
    # ê° ì—í”¼ì†Œë“œì˜ ë°ì´í„° ê¸°ë¡ ì‹œê°„ (ê¸°ë³¸ê°’: 60ì´ˆ)
    # Number of seconds for resetting the environment after each episode.
    reset_time_s: int | float = 60
    # ê° ì—í”¼ì†Œë“œ í›„ í™˜ê²½ ë¦¬ì…‹ ì‹œê°„ (ê¸°ë³¸ê°’: 60ì´ˆ)
    # Number of episodes to record.
    num_episodes: int = 50
    # ê¸°ë¡í•  ì—í”¼ì†Œë“œ ìˆ˜ (ê¸°ë³¸ê°’: 50ê°œ)
    # Encode frames in the dataset into video
    video: bool = True
    # ë°ì´í„°ì…‹ì˜ í”„ë ˆì„ì„ ë¹„ë””ì˜¤ë¡œ ì¸ì½”ë”©í• ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: True)
    # Upload dataset to Hugging Face hub.
    push_to_hub: bool = True
    # ë°ì´í„°ì…‹ì„ HuggingFace Hubì— ì—…ë¡œë“œí• ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: True)
    # Upload on private repository on the Hugging Face hub.
    private: bool = False
    # HuggingFace Hubì— ë¹„ê³µê°œ ì €ì¥ì†Œë¡œ ì—…ë¡œë“œí• ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
    # Add tags to your dataset on the hub.
    tags: list[str] | None = None
    # Hubì˜ ë°ì´í„°ì…‹ì— ì¶”ê°€í•  íƒœê·¸ë“¤ (ê¸°ë³¸ê°’: None)
    # Number of subprocesses handling the saving of frames as PNG. Set to 0 to use threads only;
    # set to â‰¥1 to use subprocesses, each using threads to write images. The best number of processes
    # and threads depends on your system. We recommend 4 threads per camera with 0 processes.
    # If fps is unstable, adjust the thread count. If still unstable, try using 1 or more subprocesses.
    num_image_writer_processes: int = 0
    # PNGë¡œ í”„ë ˆì„ì„ ì €ì¥í•˜ëŠ” ì„œë¸Œí”„ë¡œì„¸ìŠ¤ ìˆ˜ (ê¸°ë³¸ê°’: 0 = ìŠ¤ë ˆë“œë§Œ ì‚¬ìš©)
    # Number of threads writing the frames as png images on disk, per camera.
    # Too many threads might cause unstable teleoperation fps due to main thread being blocked.
    # Not enough threads might cause low camera fps.
    num_image_writer_threads_per_camera: int = 12
    # ì¹´ë©”ë¼ë‹¹ PNG ì´ë¯¸ì§€ë¥¼ ë””ìŠ¤í¬ì— ì“°ëŠ” ìŠ¤ë ˆë“œ ìˆ˜ (ê¸°ë³¸ê°’: 4)
    # Number of episodes to record before batch encoding videos
    # Set to 1 for immediate encoding (default behavior), or higher for batched encoding
    video_encoding_batch_size: int = 1
    # ë¹„ë””ì˜¤ ë°°ì¹˜ ì¸ì½”ë”© ì „ì— ê¸°ë¡í•  ì—í”¼ì†Œë“œ ìˆ˜ (ê¸°ë³¸ê°’: 1 = ì¦‰ì‹œ ì¸ì½”ë”©)

    def __post_init__(self):
    # ë°ì´í„°í´ë˜ìŠ¤ ìƒì„± í›„ ìë™ í˜¸ì¶œë˜ëŠ” ê²€ì¦ ë©”ì„œë“œ
        if self.single_task is None:
        # ì‘ì—… ì„¤ëª…ì´ ì œê³µë˜ì§€ ì•Šì•˜ìœ¼ë©´
            raise ValueError("You need to provide a task as argument in `single_task`.")



# ì „ì²´ ê¸°ë¡ ì„¤ì •ì„ ë‹´ì„ ë©”ì¸ ë°ì´í„°í´ë˜ìŠ¤ ì •ì˜
@dataclass
class RecordConfig:
    robot: RobotConfig
    # ë¡œë´‡ ì„¤ì • (í•„ìˆ˜)
    # --robot.type=koch_follower, --robot.port=/dev/ttyACM0, --robot.cameras='{...}' ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    dataset: DatasetRecordConfig
    # --dataset.repo_id=... ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    # ë°ì´í„°ì…‹ ê¸°ë¡ ì„¤ì • (í•„ìˆ˜)
    # Whether to control the robot with a teleoperator
    teleop: TeleoperatorConfig | None = None
    # --teleop.type=koch_leader ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    # í…”ë ˆì˜¤í¼ë ˆì´í„°ë¡œ ë¡œë´‡ì„ ì œì–´í• ì§€ ì—¬ë¶€ (ì„ íƒì‚¬í•­)
    # Whether to control the robot with a policy
    policy: PreTrainedConfig | None = None
    # --policy.path=... ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    # ì •ì±…ìœ¼ë¡œ ë¡œë´‡ì„ ì œì–´í• ì§€ ì—¬ë¶€ (ì„ íƒì‚¬í•­)
    # Display all cameras on screen
    display_data: bool = False
    # --display_data=true ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    # ëª¨ë“  ì¹´ë©”ë¼ë¥¼ í™”ë©´ì— í‘œì‹œí• ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
    # Use vocal synthesis to read events.
    play_sounds: bool = True
    # --play_sounds=true ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    # ìŒì„± í•©ì„±ìœ¼ë¡œ ì´ë²¤íŠ¸ë¥¼ ì½ì„ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: True)
    # Resume recording on an existing dataset.
    resume: bool = False
    # --resume=true ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±ë¨
    # ê¸°ì¡´ ë°ì´í„°ì…‹ì—ì„œ ê¸°ë¡ì„ ì¬ê°œí• ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)

    def __post_init__(self):
    # ì„¤ì • í´ë˜ìŠ¤ ìƒì„± í›„ ìë™ í˜¸ì¶œë˜ëŠ” ì´ˆê¸°í™” ë©”ì„œë“œ
        # HACK: We parse again the cli args here to get the pretrained path if there was one.
        policy_path = parser.get_path_arg("policy")
        # í•´í‚¹: ì‚¬ì „ í›ˆë ¨ëœ ì •ì±… ê²½ë¡œê°€ ìˆëŠ”ì§€ CLI ì¸ìˆ˜ë¥¼ ë‹¤ì‹œ íŒŒì‹±
        if policy_path:
        # ì •ì±… ê²½ë¡œê°€ ì œê³µë˜ì—ˆìœ¼ë©´
            cli_overrides = parser.get_cli_overrides("policy")
            # CLIì—ì„œ ì˜¤ë²„ë¼ì´ë“œëœ ì •ì±… ì„¤ì •ë“¤ ê°€ì ¸ì˜¤ê¸°
            self.policy = PreTrainedConfig.from_pretrained(policy_path, cli_overrides=cli_overrides)
            # ì‚¬ì „ í›ˆë ¨ëœ ì„¤ì •ì„ ë¡œë“œí•˜ê³  CLI ì˜¤ë²„ë¼ì´ë“œ ì ìš©
            self.policy.pretrained_path = policy_path
            # ì‚¬ì „ í›ˆë ¨ëœ ê²½ë¡œë¥¼ ì„¤ì •ì— ì €ì¥
        if self.teleop is None and self.policy is None:
        # í…”ë ˆì˜¤í¼ë ˆì´í„°ì™€ ì •ì±…ì´ ëª¨ë‘ Noneì´ë©´
            raise ValueError("Choose a policy, a teleoperator or both to control the robot")
            # ì—ëŸ¬ ë°œìƒ: "ë¡œë´‡ì„ ì œì–´í•˜ê¸° ìœ„í•´ ì •ì±…, í…”ë ˆì˜¤í¼ë ˆì´í„° ë˜ëŠ” ë‘˜ ë‹¤ ì„ íƒí•˜ì„¸ìš”"


    # íŒŒì„œê°€ ê²½ë¡œë¥¼ ë¡œë“œí•  ìˆ˜ ìˆê²Œ í•˜ëŠ” í´ë˜ìŠ¤ ë©”ì„œë“œ   
    @classmethod
    def __get_path_fields__(cls) -> list[str]:
        """This enables the parser to load config from the policy using `--policy.path=local/dir`"""
        return ["policy"]




# ì´ë¯¸ì§€ ì €ì¥ ì‘ì—…ì„ ì•ˆì „í•˜ê²Œ ì¤‘ë‹¨í•˜ëŠ” ë°ì½”ë ˆì´í„°
@safe_stop_image_writer
def record_loop(
    robot: Robot,
    events: dict,
    fps: int,
    dataset: LeRobotDataset | None = None,
    teleop: Teleoperator | list[Teleoperator] | None = None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
):
# ì‹¤ì œ ë°ì´í„° ê¸°ë¡ì„ ìˆ˜í–‰í•˜ëŠ” ë©”ì¸ ë£¨í”„ í•¨ìˆ˜
    if dataset is not None and dataset.fps != fps:
    # ë°ì´í„°ì…‹ì´ ìˆê³  FPSê°€ ìš”ì²­ëœ FPSì™€ ë‹¤ë¥´ë©´
        raise ValueError(f"The dataset fps should be equal to requested fps ({dataset.fps} != {fps}).")

    teleop_arm = teleop_keyboard = None
    # íŒ” í…”ë ˆì˜¤í¼ë ˆì´í„°ì™€ í‚¤ë³´ë“œ í…”ë ˆì˜¤í¼ë ˆì´í„° ë³€ìˆ˜ ì´ˆê¸°í™”
    if isinstance(teleop, list):
    # í…”ë ˆì˜¤í¼ë ˆì´í„°ê°€ ë¦¬ìŠ¤íŠ¸ë©´ (ë‹¤ì¤‘ í…”ë ˆì˜¤í¼ë ˆì´í„°)
        teleop_keyboard = next((t for t in teleop if isinstance(t, KeyboardTeleop)), None)
        # ë¦¬ìŠ¤íŠ¸ì—ì„œ KeyboardTeleop ì¸ìŠ¤í„´ìŠ¤ ì°¾ê¸°
        teleop_arm = next(
            (
                t
                for t in teleop
                if isinstance(t, (so100_leader.SO100Leader, so101_leader.SO101Leader, koch_leader.KochLeader))
            ),
            None,
        )
        # ë¦¬ìŠ¤íŠ¸ì—ì„œ íŒ” í…”ë ˆì˜¤í¼ë ˆì´í„° ì¸ìŠ¤í„´ìŠ¤ ì°¾ê¸°
        if not (teleop_arm and teleop_keyboard and len(teleop) == 2 and robot.name == "lekiwi_client"):
            raise ValueError(
                "For multi-teleop, the list must contain exactly one KeyboardTeleop and one arm teleoperator. Currently only supported for LeKiwi robot."
            )
        # íŒ”ê³¼ í‚¤ë³´ë“œ í…”ë ˆì˜¤í¼ë ˆì´í„°ê°€ ìˆì§€ ì•Šê±°ë‚˜, ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ê°€ 2ê°€ ì•„ë‹ˆê±°ë‚˜, ë¡œë´‡ì´ lekiwiê°€ ì•„ë‹ˆë©´

    # if policy is given it needs cleaning up
    if policy is not None:
        policy.reset()

    timestamp = 0
    # íƒ€ì„ìŠ¤íƒ¬í”„ ì´ˆê¸°í™”
    start_episode_t = time.perf_counter()
    # ì—í”¼ì†Œë“œ ì‹œì‘ ì‹œê°„ ê¸°ë¡
    while timestamp < control_time_s:
    # ì œì–´ ì‹œê°„ ë™ì•ˆ ë°˜ë³µ
        start_loop_t = time.perf_counter()
        # ë£¨í”„ ì‹œì‘ ì‹œê°„ ê¸°ë¡
        if events["exit_early"]:
        # ì¡°ê¸° ì¢…ë£Œ ì´ë²¤íŠ¸ê°€ ë°œìƒí–ˆìœ¼ë©´
            events["exit_early"] = False
            # ì´ë²¤íŠ¸ í”Œë˜ê·¸ ë¦¬ì…‹
            break

        observation = robot.get_observation()
        # ë¡œë´‡ì—ì„œ í˜„ì¬ ê´€ì°° ë°ì´í„° ì½ê¸° (ëª¨í„° ìœ„ì¹˜ + ì¹´ë©”ë¼ ì´ë¯¸ì§€ë“¤)

        if policy is not None or dataset is not None:
        # ì •ì±…ì´ë‚˜ ë°ì´í„°ì…‹ì´ ìˆìœ¼ë©´
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")
            # ê´€ì°° ë°ì´í„°ë¥¼ ë°ì´í„°ì…‹ í”„ë ˆì„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜

        
        if policy is not None:
        # ì •ì±…ì´ ìˆìœ¼ë©´ (AI ìë™ ì œì–´)
            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            # ì •ì±…ì„ ì‚¬ìš©í•´ ë‹¤ìŒ í–‰ë™ ì˜ˆì¸¡ (AIê°€ ê²°ì •í•œ ëª¨í„° ëª©í‘œ ìœ„ì¹˜ë“¤)
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
            # ì˜ˆì¸¡ëœ í–‰ë™ì„ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ë³€í™˜
        elif policy is None and isinstance(teleop, Teleoperator):
        # ì •ì±…ì´ ì—†ê³  í…”ë ˆì˜¤í¼ë ˆì´í„°ê°€ ë‹¨ì¼ ê°ì²´ë©´
            action = teleop.get_action()
            # í…”ë ˆì˜¤í¼ë ˆì´í„°ì—ì„œ í˜„ì¬ ë™ì‘ ì½ê¸° (ì‚¬ìš©ìê°€ ì¡°ì‘í•˜ëŠ” ìœ„ì¹˜ë“¤)
        elif policy is None and isinstance(teleop, list):
        # ì •ì±…ì´ ì—†ê³  í…”ë ˆì˜¤í¼ë ˆì´í„°ê°€ ë¦¬ìŠ¤íŠ¸ë©´ (ë‹¤ì¤‘ í…”ë ˆì˜¤í¼ë ˆì´ì…˜)
            # TODO(pepijn, steven): clean the record loop for use of multiple robots (possibly with pipeline)
            arm_action = teleop_arm.get_action()
            # íŒ” í…”ë ˆì˜¤í¼ë ˆì´í„°ì—ì„œ ë™ì‘ ì½ê¸°
            arm_action = {f"arm_{k}": v for k, v in arm_action.items()}
            # íŒ” ë™ì‘ì— "arm_" ì ‘ë‘ì‚¬ ì¶”ê°€
            keyboard_action = teleop_keyboard.get_action()
            # í‚¤ë³´ë“œ í…”ë ˆì˜¤í¼ë ˆì´í„°ì—ì„œ ë™ì‘ ì½ê¸°
            base_action = robot._from_keyboard_to_base_action(keyboard_action)
            # í‚¤ë³´ë“œ ì…ë ¥ì„ ë¡œë´‡ ë² ì´ìŠ¤ ë™ì‘ìœ¼ë¡œ ë³€í™˜
            action = {**arm_action, **base_action} if len(base_action) > 0 else arm_action
            # íŒ” ë™ì‘ê³¼ ë² ì´ìŠ¤ ë™ì‘ì„ ê²°í•© (ë² ì´ìŠ¤ ë™ì‘ì´ ìˆìœ¼ë©´)
        else:
            logging.info(
                "No policy or teleoperator provided, skipping action generation."
                "This is likely to happen when resetting the environment without a teleop device."
                "The robot won't be at its rest position at the start of the next episode."
            )
            continue

        # Action can eventually be clipped using `max_relative_target`,
        # so action actually sent is saved in the dataset.
        sent_action = robot.send_action(action)
        # ë¡œë´‡ì— ë™ì‘ ì „ì†¡ (max_relative_targetìœ¼ë¡œ ì œí•œë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì‹¤ì œ ì „ì†¡ëœ ë™ì‘ ë°˜í™˜)
        if dataset is not None:
        # ë°ì´í„°ì…‹ì´ ìˆìœ¼ë©´ (ê¸°ë¡ ì¤‘ì´ë©´
            action_frame = build_dataset_frame(dataset.features, sent_action, prefix="action")
            frame = {**observation_frame, **action_frame}
            # ì‹¤ì œ ì „ì†¡ëœ ë™ì‘ì„ ë°ì´í„°ì…‹ í”„ë ˆì„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            # ê´€ì°°ê³¼ ë™ì‘ í”„ë ˆì„ì„ ê²°í•©
            dataset.add_frame(frame, task=single_task)
            # ë°ì´í„°ì…‹ì— í”„ë ˆì„ ì¶”ê°€ (observation + action ìŒ ì €ì¥)


        if display_data:
        #  ë°ì´í„° í‘œì‹œê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´
            log_rerun_data(observation, action)
            # Rerun ë·°ì–´ì— ë°ì´í„° ì „ì†¡ (3D ì‹œê°í™”)

        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)
        # ì •í™•í•œ FPS ìœ ì§€ë¥¼ ìœ„í•œ ëŒ€ê¸°

        timestamp = time.perf_counter() - start_episode_t
        


# CLI íŒŒì„œ ë˜í¼ ë°ì½”ë ˆì´í„°
@parser.wrap()
# @parser.wrap()ê°€ CLI ì¸ìˆ˜ë“¤ì„ ì½ì–´ RecordConfigì™€ ê·¸ í•˜ìœ„ DatasetRecordConfig/RobotConfig/TeleoperatorConfigë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
# ì˜ˆ: --dataset.repo_id=... â†’ cfg.dataset.repo_id
# ì˜ˆ: --robot.type=koch_follower, --robot.port=/dev/ttyACM0, --robot.cameras='{...}' â†’ cfg.robot ì•ˆìª½ í•„ë“œë“¤
# ì˜ˆ: --teleop.type=koch_leader â†’ cfg.teleop
# ì˜ˆ: --display_data=true â†’ cfg.display_data
def record(cfg: RecordConfig) -> LeRobotDataset:
# ë©”ì¸ ê¸°ë¡ í•¨ìˆ˜ ì •ì˜
    init_logging()
    # ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    logging.info(pformat(asdict(cfg)))
    # ì„¤ì • ì •ë³´ë¥¼ ë¡œê·¸ë¡œ ì¶œë ¥
    if cfg.display_data:
    # ì¡°ê±´ ê²€ì‚¬: --display_data=trueë¡œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸
    # Trueë©´ ì‹¤ì‹œê°„ 3D ì‹œê°í™” í™œì„±í™” ì¤€ë¹„
        _init_rerun(session_name="recording")
        # Rerun ì´ˆê¸°í™”: 3D ì‹œê°í™” ë·°ì–´ ì‹œì‘
        # session_name="recording": ì„¸ì…˜ ì´ë¦„ ì„¤ì •
        # ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¡œë´‡ ìƒíƒœ/ì¹´ë©”ë¼ ì˜ìƒ ë³¼ ìˆ˜ ìˆìŒ
    robot = make_robot_from_config(cfg.robot)
    # ë¡œë´‡ ê°ì²´ ìƒì„±: ì„¤ì •ì— ë”°ë¼ ë¡œë´‡ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    # cfg.robot.typeì— ë”°ë¼ ë‹¤ë¥¸ ë¡œë´‡ í´ë˜ìŠ¤ ì„ íƒ:
    # "koch_follower" â†’ KochFollower í´ë˜ìŠ¤
    # "so100_follower" â†’ SO100Follower í´ë˜ìŠ¤
    # í¬íŠ¸, ì¹´ë©”ë¼, ID ë“± ëª¨ë“  ì„¤ì •ì´ ë¡œë´‡ ê°ì²´ì— ì ìš©ë¨
    teleop = make_teleoperator_from_config(cfg.teleop) if cfg.teleop is not None else None
    # ì¡°ê±´ë¶€ í…”ë ˆì˜¤í¼ë ˆì´í„° ìƒì„±:
    # cfg.teleop is not None: í…”ë ˆì˜¤í¼ë ˆì´í„° ì„¤ì •ì´ ìˆìœ¼ë©´
    # make_teleoperator_from_config(cfg.teleop): í…”ë ˆì˜¤í¼ë ˆì´í„° ê°ì²´ ìƒì„±
    # ì—†ìœ¼ë©´ None (ì •ì±…ë§Œìœ¼ë¡œ ì œì–´í•˜ê±°ë‚˜ ìˆ˜ë™ ë¦¬ì…‹ìš©)
    action_features = hw_to_dataset_features(robot.action_features, "action", cfg.dataset.video)
    # ì•¡ì…˜ íŠ¹ì„± ë³€í™˜: í•˜ë“œì›¨ì–´ ì•¡ì…˜ì„ ë°ì´í„°ì…‹ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    # robot.action_features: ë¡œë´‡ì´ ì œì–´í•  ìˆ˜ ìˆëŠ” ê´€ì ˆë“¤ (ì˜ˆ: ["arm_joint_1", "arm_joint_2", "gripper"])
    # "action": ì ‘ë‘ì‚¬ë¡œ "action.arm_joint_1" í˜•íƒœê°€ ë¨
    # cfg.dataset.video: ë¹„ë””ì˜¤ ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¼ ì €ì¥ ë°©ì‹ ê²°ì •
    obs_features = hw_to_dataset_features(robot.observation_features, "observation", cfg.dataset.video)
    # ê´€ì°° íŠ¹ì„± ë³€í™˜: í•˜ë“œì›¨ì–´ ì„¼ì„œ ë°ì´í„°ë¥¼ ë°ì´í„°ì…‹ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    # robot.observation_features: ë¡œë´‡ì´ ì½ì„ ìˆ˜ ìˆëŠ” ì„¼ì„œë“¤
    # ê´€ì ˆ ìœ„ì¹˜: ["arm_joint_1", "arm_joint_2"]
    # ì¹´ë©”ë¼: {"laptop": CameraConfig, "wrist": CameraConfig}
    # ê²°ê³¼: "observation.state.arm_joint_1", "observation.images.laptop" ë“±
    dataset_features = {**action_features, **obs_features}
    # ì•¡ì…˜ê³¼ ê´€ì°° íŠ¹ì„±ì„ ê²°í•©
    # íŠ¹ì„± í•©ë³‘: ì•¡ì…˜ê³¼ ê´€ì°° íŠ¹ì„±ì„ í•˜ë‚˜ì˜ ë”•ì…”ë„ˆë¦¬ë¡œ ê²°í•©
    # ** ì—°ì‚°ì: ë”•ì…”ë„ˆë¦¬ ì–¸íŒ¨í‚¹ (ë‘ ë”•ì…”ë„ˆë¦¬ ë‚´ìš©ì„ í•©ì¹¨)
    # ìµœì¢…ê²°ê³¼
    #     {
    #     "action.arm_joint_1": {"dtype": "float32"},
    #     "observation.state.arm_joint_1": {"dtype": "float32"},  
    #     "observation.images.laptop": {"shape": [480, 640, 3], "dtype": "uint8"}
    # }



    if cfg.resume:
    # ì¬ê°œ ëª¨ë“œ ê²€ì‚¬: --resume=trueë¡œ ê¸°ì¡´ ë°ì´í„°ì…‹ ì´ì–´ì„œ ê¸°ë¡í•  ê±´ì§€
        dataset = LeRobotDataset(
            cfg.dataset.repo_id,
            root=cfg.dataset.root,
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )
        # ê¸°ì¡´ ë°ì´í„°ì…‹ ë¡œë“œ: ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°ì´í„°ì…‹ í´ë”ì—ì„œ ë¡œë“œ
        # cfg.dataset.repo_id: ì˜ˆ) "aliberts/pick-cube"
        # root=cfg.dataset.root: ë¡œì»¬ ì €ì¥ ê²½ë¡œ (Noneì´ë©´ ê¸°ë³¸ ìºì‹œ ë””ë ‰í† ë¦¬)
        # batch_encoding_size: ëª‡ ê°œ ì—í”¼ì†Œë“œì”© ëª¨ì•„ì„œ ë¹„ë””ì˜¤ ì¸ì½”ë”©í• ì§€
        if hasattr(robot, "cameras") and len(robot.cameras) > 0:
        # ì˜ìƒ ë°ì´í„° ì €ì¥ì„ í•˜ì§€ ì•Šê¸° ìœ„í•´ì„œ íŒ¨ìŠ¤í•¨
        # ë¡œë´‡ì— ì¹´ë©”ë¼ê°€ ìˆìœ¼ë©´
            dataset.start_image_writer(
                num_processes=cfg.dataset.num_image_writer_processes,
                num_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            )
            # ì´ë¯¸ì§€ ì €ì¥ ì‘ì—… ì‹œì‘ (ë©€í‹°í”„ë¡œì„¸ì‹±/ë©€í‹°ìŠ¤ë ˆë”©ìœ¼ë¡œ)
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.dataset.fps, dataset_features)
        # ë°ì´í„°ì…‹ê³¼ ë¡œë´‡ì˜ í˜¸í™˜ì„± ê²€ì‚¬

    else:
    # ìƒˆ ë°ì´í„°ì…‹ ìƒì„± ëª¨ë“œë©´
    # ë°ì´í„°ì…‹ ì´ë¦„ ìœ íš¨ì„± ê²€ì‚¬:
    # HuggingFace Hub ê·œì¹™ì— ë§ëŠ” ì´ë¦„ì¸ì§€ í™•ì¸ (ì˜ˆ: "ì‚¬ìš©ìëª…/ë°ì´í„°ì…‹ëª…")
    # ì •ì±…ê³¼ ë°ì´í„°ì…‹ ì´ë¦„ì´ ì¶©ëŒí•˜ì§€ ì•ŠëŠ”ì§€ ê²€ì‚¬
        # Create empty dataset or load existing saved episodes
        sanity_check_dataset_name(cfg.dataset.repo_id, cfg.policy)
        # ë°ì´í„°ì…‹ ì´ë¦„ ìœ íš¨ì„± ê²€ì‚¬
        # ì´ê±¸ë¡œ ì¸í•´ ë§Œë“¤ì–´ì§ˆ ë°ì´í„° ì…‹ êµ¬ì¡°ëŠ” ì´ë ‡ê²Œ ëœë‹¤
        dataset = LeRobotDataset.create(
            cfg.dataset.repo_id,
            cfg.dataset.fps,
            root=cfg.dataset.root,
            robot_type=robot.name,
            features=dataset_features,
            use_videos=cfg.dataset.video,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )
        # ìƒˆ LeRobot ë°ì´í„°ì…‹ ìƒì„± (HDF5 íŒŒì¼ + ë©”íƒ€ë°ì´í„°)
    # cfg.dataset.repo_id: ë°ì´í„°ì…‹ ì´ë¦„
    # cfg.dataset.fps: 30 (ì´ˆë‹¹ 30í”„ë ˆì„ìœ¼ë¡œ ê¸°ë¡)
    # robot_type=robot.name: ë¡œë´‡ íƒ€ì… ë©”íƒ€ë°ì´í„°ì— ì €ì¥
    # features=dataset_features: ì•ì„œ ë§Œë“  ë°ì´í„° ìŠ¤í‚¤ë§ˆ
    # use_videos=cfg.dataset.video: ë¹„ë””ì˜¤ ì••ì¶• ì‚¬ìš©í• ì§€ (True/False)
    # image_writer_processes: ì´ë¯¸ì§€ ì €ì¥ìš© ì„œë¸Œí”„ë¡œì„¸ìŠ¤ ê°œìˆ˜ (0 = ìŠ¤ë ˆë“œë§Œ)
    # image_writer_threads: ì´ ìŠ¤ë ˆë“œ ê°œìˆ˜ (ì¹´ë©”ë¼ë‹¹ ìŠ¤ë ˆë“œ ìˆ˜ Ã— ì¹´ë©”ë¼ ê°œìˆ˜)
    # Load pretrained policy
    # ìƒì„±ë˜ëŠ” í´ë” êµ¬ì¡°
    # â”œâ”€â”€ data/           # HDF5 íŒŒì¼ë“¤
    # â”œâ”€â”€ videos/         # MP4 íŒŒì¼ë“¤  
    # â”œâ”€â”€ meta.json       # ë©”íƒ€ë°ì´í„°
    # â””â”€â”€ README.md       # ìë™ ìƒì„± ë¬¸ì„œ
    policy = None if cfg.policy is None else make_policy(cfg.policy, ds_meta=dataset.meta)
    # ì •ì±… ì„¤ì •ì´ ìˆìœ¼ë©´ ì‚¬ì „ í›ˆë ¨ëœ ì •ì±… ë¡œë“œ
    robot.connect()
    # ë¡œë´‡ì— ì—°ê²° (ëª¨í„° + ì¹´ë©”ë¼ ì—°ê²°)
    if teleop is not None:
        teleop.connect()

    listener, events = init_keyboard_listener()

    with VideoEncodingManager(dataset):
        recorded_episodes = 0
        while recorded_episodes < cfg.dataset.num_episodes and not events["stop_recording"]:
            log_say(f"Recording episode {dataset.num_episodes}", cfg.play_sounds)
            record_loop(
                robot=robot,
                events=events,
                fps=cfg.dataset.fps,
                teleop=teleop,
                policy=policy,
                dataset=dataset,
                control_time_s=cfg.dataset.episode_time_s,
                single_task=cfg.dataset.single_task,
                display_data=cfg.display_data,
            )

            # Execute a few seconds without recording to give time to manually reset the environment
            # Skip reset for the last episode to be recorded
            if not events["stop_recording"] and (
                (recorded_episodes < cfg.dataset.num_episodes - 1) or events["rerecord_episode"]
            ):
                log_say("Reset the environment", cfg.play_sounds)
                record_loop(
                    robot=robot,
                    events=events,
                    fps=cfg.dataset.fps,
                    teleop=teleop,
                    control_time_s=cfg.dataset.reset_time_s,
                    single_task=cfg.dataset.single_task,
                    display_data=cfg.display_data,
                )

            if events["rerecord_episode"]:
                log_say("Re-record episode", cfg.play_sounds)
                events["rerecord_episode"] = False
                events["exit_early"] = False
                dataset.clear_episode_buffer()
                continue
            

            # ì—í”¼ì†Œë“œ ì €ì¥
            dataset.save_episode()
            recorded_episodes += 1

    log_say("Stop recording", cfg.play_sounds, blocking=True)
    # ê¸°ë¡ ì¤‘ì§€ í•™ìŠµ ì¤‘ì§€ 
    
    robot.disconnect()
    if teleop is not None:
        teleop.disconnect()

    if not is_headless() and listener is not None:
        listener.stop()

    if cfg.dataset.push_to_hub:
        dataset.push_to_hub(tags=cfg.dataset.tags, private=cfg.dataset.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset


def main():
    dataset = record()
    
    try:
        import subprocess
        import sys
        
        # ê°„ë‹¨í•œ ì‘ì—… íƒ€ì… íŒë‹¨
        def get_task_type():
            full_info = ' '.join(sys.argv).lower()
            if hasattr(dataset, 'meta') and hasattr(dataset.meta, 'single_task'):
                full_info += " " + str(dataset.meta.single_task).lower()
            
            if any(keyword in full_info for keyword in ['pick_place', 'safebox', 'box', 'place']):
                return 'pick_place'
            return 'button_task'
        
        # âœ… conda í™˜ê²½ ì™„ì „ ë¹„í™œì„±í™”í•˜ê³  ì‹œìŠ¤í…œ Python ì‚¬ìš©
        task_type = get_task_type()
        topic = '/robot_arm/pick_and_place_end' if task_type == 'pick_place' else '/robot_arm/button_end'
        
        # ì‹œìŠ¤í…œ í™˜ê²½ì—ì„œë§Œ ì‹¤í–‰í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸
        ros_command = f'''
# conda í™˜ê²½ ì™„ì „ ë¹„í™œì„±í™”
unset CONDA_PREFIX
unset CONDA_DEFAULT_ENV
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# ì‹œìŠ¤í…œ ROS2 í™˜ê²½ ì„¤ì •
source /opt/ros/humble/setup.bash
export ROS_DOMAIN_ID=77

echo "ğŸ”„ ì‹œìŠ¤í…œ ROS2 í™˜ê²½ì—ì„œ ì™„ë£Œ ì‹ í˜¸ ë°œí–‰ ì¤‘..."

# ì‹œìŠ¤í…œ Pythonìœ¼ë¡œ ROS2 ì‹¤í–‰
/usr/bin/python3 -c "
import rclpy
from rclpy.node import Node
from std_msgs.msg import Empty
import time

print('ğŸ”„ ROS2 ì´ˆê¸°í™” ì¤‘...')
rclpy.init()
node = Node('lerobot_completion')
pub = node.create_publisher(Empty, '{topic}', 10)

# êµ¬ë…ì ëŒ€ê¸°
for i in range(20):
    if pub.get_subscription_count() > 0:
        print(f'âœ… êµ¬ë…ì {{pub.get_subscription_count()}}ëª… ë°œê²¬!')
        break
    print(f'â³ êµ¬ë…ì ëŒ€ê¸° ì¤‘... {{i+1}}/20')
    time.sleep(0.5)

# ì™„ë£Œ ì‹ í˜¸ ë°œí–‰
msg = Empty()
pub.publish(msg)
print('ğŸ“¡ ì™„ë£Œ ì‹ í˜¸ ë°œí–‰ ì™„ë£Œ!')
time.sleep(2)

node.destroy_node()
rclpy.shutdown()
print('âœ… ì™„ë£Œ ì‹ í˜¸ ë°œí–‰ ì„±ê³µ: {topic}')
"

echo "ğŸ‰ ì™„ë£Œ!"
sleep 3
exit
'''
        
        # ìƒˆ í„°ë¯¸ë„ì—ì„œ ì‹¤í–‰
        subprocess.Popen([
            'gnome-terminal', 
            '--', 
            'bash', 
            '-c', 
            ros_command
        ])
        
        task_name = 'ìƒì ì ì¬' if task_type == 'pick_place' else 'ë²„íŠ¼ ì‘ì—…'
        print(f"ğŸ‰ LeRobot ì‘ì—… ì™„ë£Œ! {task_name} ì™„ë£Œ ì‹ í˜¸ë¥¼ ì‹œìŠ¤í…œ í™˜ê²½ì—ì„œ ë°œí–‰í•©ë‹ˆë‹¤.")
        
    except Exception as e:
        print(f"âŒ ì™„ë£Œ ì‹ í˜¸ ë°œí–‰ ì‹¤íŒ¨: {e}")
        print("LeRobot ì‘ì—…ì€ ì •ìƒì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")


if __name__ == "__main__":
    main()
